require 'ostruct'

module PublicEarth
  module Db
    module PlaceExt
      
      # Methods for looking up places from the database.
      #
      # The methods in this module will be incorporated into the Place model at the class level, rather
      # than included as instance methods.
      module Finders

        # Loads not only the place, but its category info and all the attributes.  Throws an exception
        # if it doesn't exist.
        def find_by_id!(id)
          with_details(many.find_with_attributes(id)) 
        rescue RecordNotFound
          raise "A #{name} record for #{id} does not exist."
        end

        # Loads not only the place, but its category info and all the attributes.  Returns nil if it
        # doesn't exist.
        def find_by_id(id)
          results = many.find_with_attributes_ne(id)
          results.blank? && nil || with_details(results)
        end

        def find_raw_by_id!(id)
          new(one.get_raw(id))
        end

        # Look for a set of place IDs and their corresponding categories by slug.  Returns an map of
        # category => place_id.
        def find_slug_matches(id)
          Hash[*(many.find_by_slug(id).map {|results| [results['category_id'], results['id']]}).flatten]
        end
        
        # Search for places.  You can search in general or within a bounding box.  Possible parameters:
        #
        #   :query => required
        #   :language => 'english' (default)
        #   :max_results => 10 (default)
        #   :start => 0 (default)
        #   :min_latitude => optional
        #   :min_longitude => optional
        #   :max_latitude => optional
        #   :max_longitude => optional
        #
        # If you include latitude and longitude information, will search for places inside the given
        # bounding box.  Otherwise does a general search regardless of location.
        #
        def search_within(bounding_box, query, offset = 0, limit = 5, language = 'english')
          if bounding_box[:sw][:latitude]
            many.search_within(query, language, limit, offset, bounding_box[:sw][:latitude], bounding_box[:sw][:longitude], bounding_box[:ne][:latitude], bounding_box[:ne][:longitude]).map { |attributes| PublicEarth::Db::Place.new(attributes) }
          else
            many.search(query, language, limit, offset).map { |attributes| PublicEarth::Db::Place.new(attributes) }
          end
        end

        # Return a single random place.  Handy for testing.
        def random
          new(one.random())
        end

        # Look up a similar place by its name and lat/long.  This is a first step down the troublesome
        # road of deduping.
        def match(name, category, latitude, longitude)
          new(one.match(name, category.id, latitude, longitude) || raise(RecordNotFound, 
              "No matching places found for #{name} in #{category.id} around #{latitude} x #{longitude}."))
        end

        # Look up a similar place by its name, category and geometry.  This is 
        # for deduping regions and routes.
        def matchshape(name, category, geometry)
          new(one.match(name, category.id, geometry) || raise(RecordNotFound,
              "No matching places found for #{name} in #{category.id} around #{geometry}."))
        end
        
        # Return the list of likely duplcate places for the deduping feature
        def matches(name, latitude, longitude, category = nil)
          category_id = category.id if category
          
          # Want to append the distance and similarity rankings.
          matched_places = Hash[*(many.matches(name, latitude, longitude, category_id).map {|r| [r['id'], r]}).flatten]
          find_from_search(*matched_places.keys).map do |place|
            if place
              if matched_places[place.id]
                place.distance_in_meters = matched_places[place.id]['distance_in_meters'] 
                place.name_similarity = matched_places[place.id]['name_similarity'] 
              end
              place
            end
          end
        end

        # Create a place from JSON hash, typically generated by the to_json method on the object.
        def from_json(json)
          new JSON.parse(json)
        end

        # Takes the place information and attribute details from a single query, typically as we're
        # cycling through large data sets, and creates a Place object with fully filled details and
        # category information.  See each_with_details and created_by_user.
        def with_details(results)
          first = results.first
          if first
            place = new(:id => first['place_id'],
                        :name => first['place_name'],
                        :slug => first['place_slug'],
                        :created_at => first['place_created_at'],
                        :updated_at => first['place_updated_at'], 
                        :latitude => first['latitude'], 
                        :longitude => first['longitude'],
                        :route => first['route'], 
                        :route_length => first['route_length'],
                        :region => first['region'], 
                        :region_area => first['region_area'],
                        :category_id => first['category_id'],
                        :head => first['head'], 
                        :rating => first['rating'],
                        :number_of_ratings => first['number_of_ratings'],
                        :utm_srid => first['utm_srid'],
                        :featured => first['featured'],
                        :copyright => first['copyright'] )

            # If this place is a route, encode it.
            if place.route != nil && !place.route.empty?
              encoder = PublicEarth::Db::PlaceExt::PolylineEncoder.new
              place.encoded_route = "#{encoder.dp_encode(place.route)}" # _force_ this to be a string no matter what.
              place.encoded_route_levels = encoder.encoded_levels
              place.encoded_route_zoom_factor = encoder.zoom_factor
              place.encoded_route_num_zoom_levels = encoder.num_levels
            end 

            # If this place is a region, encode it.
            if place.region != nil && !place.region.empty?
              encoder = PublicEarth::Db::PlaceExt::PolylineEncoder.new
              place.encoded_region = "#{encoder.dp_encode(place.region)}" # _force_ this to be a string no matter what.
              place.encoded_region_levels = encoder.encoded_levels
              place.encoded_region_zoom_factor = encoder.zoom_factor
              place.encoded_region_num_zoom_levels = encoder.num_levels
            end 

            # TODO:  Handle categories in different languages?  Maybe cache the categories? 
            place.category = PublicEarth::Db::Category.new :id => first['category_id'], :name => first['category_name'], 
                :slug => first['category_slug']

            # ...then cycle through the entire set of results for the details/attributes
            place.details = PublicEarth::Db::Details.new(place, nil, nil, results)

            # Set the correct name, from attributes
            place.name = place.details.name unless place.details.attributes[:name].blank?
          end
          place
        end

        # Cycle through each place and do something to it.  Passes the place object into the block.  Loads
        # up the place attributes/details with each call, so it's more efficient if you need the place
        # attributes/details to use this rather than just plain "each".
        def each_with_details
          transaction do
            cursor = connection.select_value("select place.all_with_attributes('place_cursor')")
            place = nil
            begin
              # We have to strip off the place information from the first record...
              results = many.next_with_attributes(cursor)
              unless results.empty?
                place = with_details(results)
                yield place
              else
                place = nil
              end
            end while !place.nil?
          end
        end
        alias :each_with_attributes :each_with_details

        def each_with_details_by_data_set(source_data_set)
          transaction do
            cursor = connection.select_value("select place.all_id_only_by_data_set('#{source_data_set.id}', 'place_cursor')")
            place = nil
            begin
              # We have to strip off the place information from the first record...
              results = many.next_id(cursor)

              if results.first['next_id'].present?
                place = PublicEarth::Db::Place.find_by_id(results.first['next_id'])
                yield place
              else
                place = nil
              end
            end while !place.nil?
            
            connection.execute("CLOSE #{cursor}");
          end
        end

        # Runs a query for places and details against a cursor.  Returns the array of Place objects with
        # their category and details information filled in already.
        def query_with_cursor(sql_query, limit = nil)
          places = []
          transaction do
            ActiveRecord::Base.uncached do
              cursor = connection.select_value(sql_query)
              place = nil
              begin
                results = many.next_with_attributes(cursor)
                unless results.empty?
                  place = with_details(results)
                  places << place
                  if (limit)
                    limit -= 1
                    place = nil if limit == 0
                  end
                else
                  place = nil
                end
              end while !place.nil?
            end
          end
          places
        end

        # Cycle through each place and do something to it.  Passes the place object into the block.  Loads
        # up the place attributes/details with each call, so it's more efficient if you need the place
        # attributes/details to use this rather than just plain "each".
        #
        # Cycles through all places that have a search_indexed_at value of null, i.e. they have not been 
        # indexed in Solr yet.
        def unindexed_with_details
          transaction do
            cursor = connection.select_value("select place.unindexed_with_attributes('place_cursor')")
            place = nil
            begin
              # We have to strip off the place information from the first record...
              results = many.next_with_attributes(cursor)
              unless results.empty?
                place = with_details(results)
                yield place
              else
                place = nil
              end
            end while !place.nil?
          end
        end
        alias :unindexed_with_attributes :unindexed_with_details

        # Return the list of places created by the user.  Returns all by default, which can take a while!
        def created_by_user(user_id, source_id, number_to_return = :all, starting_index = 0)
          # ids = PublicEarth::Db::Place.many.created_by_user(user_id, source_id, number_to_return == :all && 250 || number_to_return, starting_index).map { |result| result['created_by_user'] }
          ids = PublicEarth::Db::Place.many.created_by_user(user_id, source_id).map { |result| result['created_by_user'] }
          PublicEarth::Db::Place.find_from_search(*ids)
        end

        # Return the list of places modified by the user (not created).  Returns all by default, which can
        # take a while!
        def modified_by_user(user_id, source_id, number_to_return = :all, starting_index = 0)
          # ids = PublicEarth::Db::Place.many.modified_by_user(user_id, source_id, number_to_return == :all && 250 || number_to_return, starting_index).map { |result| result['modified_by_user'] }
          ids = PublicEarth::Db::Place.many.modified_by_user(user_id, source_id).map { |result| result['modified_by_user'] }
          PublicEarth::Db::Place.find_from_search(*ids)
        end

        # Return the list of places in the given collection.
        def in_collection(collection_id)
          query_with_cursor("select place.in_collection('#{escape_quotes(collection_id)}', 'place_cursor')")
        end

        def featured(max = 25)
          query_with_cursor("select place.featured_with_attributes('place_cursor')", max)
        end

        def featured_in_bounds(swy, swx, ney, nex, max = 25)
          query_with_cursor("select place.featured_with_attributes('place_cursor', #{swy}, #{swx}, #{ney}, #{nex})", max)
        end

        # Use this to run a query on the database, get back a collection of place IDs, and get the 
        # place content from the search engine, which is faster than loading from the database (search
        # data is denormalized).
        def results_from_search(query_results)
          ids = query_results.map do |result|
            result['id']
          end
          find_from_search(*ids)
        end
        
        # Return the places within the bounding box that are "featured".  Unlike featured_in_bounds,
        # this method uses a quick DB GIS query, then loads the actual results from the search engine.
        def popular_within_bounds(swy, swx, ney, nex, to_return = 10, start_from = 0)
          results_from_search many.popular_within_bounds(swy, swx, ney, nex, to_return, start_from)
        end

        # Return the places in a category in the given bounding box.  You may also indicate the
        # number of place results to return, and the index number to start from (for pagination).
        def category_in_bounds(swy, swx, ney, nex, category_id, to_return = 10, start_from = 0)
          results_from_search many.within_bounds_in_category(swy, swx, ney, nex, category_id, to_return, start_from)
        end

        # Return the places in the given bounding box.  You may also indicate the
        # number of place results to return, and the index number to start from (for pagination).
        def in_bounds(swy, swx, ney, nex, to_return = 10, start_from = 0)
          results_from_search many.within_bounds(swy, swx, ney, nex, to_return, start_from)
        end

        # Return the places in a category in the given bounding box.  You may also indicate the
        # number of place results to return, and the index number to start from (for pagination).
        def featured_in_category_in_bounds(swy, swx, ney, nex, category_id, to_return = 10, start_from = 0)
          results_from_search many.popular_within_bounds_in_category(swy, swx, ney, nex, category_id, to_return, start_from)
        end
        
        # Count the number of places in the given categories and all their child categories in the bounding box
        # given.  
        def number_of_places_in_categories_within_bounds(categories, bounds)
          one.number_of_places_in_categories_within_bounds(sql_categories(categories), bounds[:sw][:latitude], 
               bounds[:sw][:longitude], bounds[:ne][:latitude], bounds[:ne][:longitude])['number_of_places_in_categories_within_bounds'].to_i
        end
        
        # Find all the places in the given categories and their children.  
        def places_in_categories_within_bounds(categories, bounds, to_return = 10, start_from = 0)
          results_from_search many.places_in_categories_within_bounds(sql_categories(categories), bounds[:sw][:latitude], 
              bounds[:sw][:longitude], bounds[:ne][:latitude], bounds[:ne][:longitude], to_return, start_from)
        end


        ### FOR GA/COSTS ###
        
        def random_within_bounds(swy, swx, ney, nex, to_return)
          # results_from_search many.random_within_bounds(swy, swx, ney, nex, to_return)
          many.random_within_bounds(swy, swx, ney, nex, to_return).map do |result|
            { :id => result['id'], :name => result['name'] }
          end
        end
        
        def cost(place_id)
          one.cost(place_id)['cost'].to_i
        end
        


        # Take a comma-separated list of categories and convert them to something compatible for our SQL calls.
        # Converts:
        #
        #   "dogs, cats, puppies, can''t"
        #
        # To:
        #
        #   "'dogs','cats','puppies','can''t'"
        #
        def sql_categories(categories)
          (categories.split(/,/).map {|c| "'#{c.strip.gsub(/'/, '\'\'')}'"}).join(',')
        end
        
        def recently_changed
          many.recently_changed.map {|hash| new(hash) }
        end

        # Use memcache instead....?
        def top_user_contributors
          @top_user_contributors ||= many.top_user_contributors
        end

        def top_user_contributors
          many.top_user_contributors
        end
        
        # Use memcache instead....?
        def place_stats
          @place_stats ||= many.place_stats
        end

        def place_stats
          many.place_stats
        end
        
        def count
          one.fast_count['fast_count'].to_i
        end
        
        def all_id_only(start, limit, &block) 
          transaction do
            cursor = connection.select_value("select place.all_id_only('place_cursor', #{start}, #{limit})")
            place_row = nil
            
            ActiveRecord::Base.uncached do
              begin
                place_row = one.next_id(cursor)
              
                if place_row.present? && place_row['next_id'].present?
                  yield place_row['next_id']
                end
              
              end while !place_row['next_id'].nil?
            end
          end
        end
        
        # Quick method to look up the name of a place.  Very fast.
        def lookup_name(place_id)
          one.get_name(place_id).values.first
        end
      end
    end
  end
end
